# Food-web structural models in R

<!--
%\VignetteIndexEntry{Food-web structural models in R}
%\VignetteEngine{knitr::rmarkdown}
%\usepackage[utf8]{inputenc}
-->

## Links generator functions
Links generator functions takes two mandatory arguments:

* `n` - the number of sets of links to generate
* `S` - the number of species

Links generator functions should return a list of `n` `matrices`, each of which
has with two columns: `resource` and `consumer`. Links generator functions can
take as many more arguments as they like.

Probably the simplest method of assigning trophic links is at random. In
addition to `pool` and `n`, the `RandomLinks` function takes:

* `C` - directed connectance (number of links / number of possible links)

So for a pool of ten species and C of 0.15, `RandomLinks` will return 
`n` `matrices` containing number.of.possible.links * C = 10 * 10 *0.15 = 15 links.
```{r}
library(Basingstoke)

# A list containing a single data.frame of 15 links
res <- RandomLinks(n=1, S=10, C=0.15)
res

# A list containing 10 data.frames, each of 15 links
res <- RandomLinks(n=10, S=10, C=0.15)
length(res)
sapply(res, nrow)
res[[1]]
```

Basingstoke provides links generator functions that implement the cascade model
and niche model:
```{r}
cascade <- CascadeModelLinks(n=1, S=10, C=0.15)
cascade

niche <- NicheModelLinks(n=1, S=10, C=0.15)
niche
```

`NicheModelLinks` takes some more arguments - `probabilistic` (if `TRUE`, the
function uses the probabilistic niche model of Williams et al 2010 PLoS One) and
`niche.positions` (species' positions on the niche axis) - these are illustrated
further down.

Basingstoke provides functions that convert between the `lists of links` form
and the familiar `predation matrix` form:

```{r}
niche.pm <- PMOfLinks(niche, 10)
niche.pm

all.equal(niche, LinksOfPM(niche.pm))
```

Links generators can be used on their own. Basingstoke can be combined with the
Cheddar food-web package.

## Generating artificial communities
The `CommunityFactory` function uses a links generator to create Cheddar
Communities:

```
CommunityFactory(S, nodes, generator=NicheModelLinks, n=1,
                 accept=NULL, energetically.feasible=TRUE,
                 trace.progress=FALSE, validate=TRUE, ...)
```
Returns a collection of artificially generated communities. 

* `S` - number of nodes in the generated communities; nodes will be named
`Node 1`...`Node S`
* `nodes` - either node names or a data.frame of node properties

Either `S` or `nodes` should be provided.

* `generator` - the function used to generate sets of trophic links
* `n` - number of communities to generate
* `accept` - either `NULL` or a function that takes a community as its only 
    argument and returns a logical; if not `NULL` then only communities for
    which the function returns `TRUE` will be returned
* `energetically.feasible` - if `TRUE`, then then only communities that are
    energetically feasible according to the `PreyAveragedTrophicLevel` function
    will be returned
* `trace.progress` - if `TRUE`, then feedback is printed
* `validate` - if `TRUE`, created communities are validated using the checks
    provided by Cheddar's `Community` function
* `...` - other arguments passed to `generator`

Use the niche model to create 12 communities containing 25 species with C&asymp;0.15. 
```{r}
library(cheddar)
communities <- CommunityFactory(S=25, n=12, generator=NicheModelLinks, C=0.15)

# Communities are named 'Artificial community 1'..'Artificial community n'
names(communities)

# Each has 25 nodes
sapply(communities, NumberOfNodes)

# Each has a C close to 0.15
sapply(communities, DirectedConnectance)
hist(sapply(communities, DirectedConnectance))

# Plot nodes stacked vertically by trophic level
plot(communities, ncol=4)

# At least one community will have a non-zero number of isolated nodes
sapply(communities, function(c) return(length(IsolatedNodes(c))))
```

We can use the `accept` argument to ensure that the communities have no isolated
nodes.
```{r}
communities <- CommunityFactory(S=25,
                                n=12,
                                generator=NicheModelLinks,
                                C=0.15,
                                accept=function(c) 0==sum(IsIsolatedNode(c)))

# All zero
sapply(communities, function(c) return(length(IsolatedNodes(c))))
```

Guarantee that communities have no isolated nodes and exactly 5 basal nodes; 
also get CommunityFactory to trace its progress.
```
communities <- CommunityFactory(S=25,
                                n=12,
                                generator=NicheModelLinks,
                                C=0.15,
                                accept=function(c) 0==sum(IsIsolatedNode(c)) && 5==sum(IsBasalNode(c)),
                                trace.progress=TRUE)

# No community has isolated nodes
all(0==sapply(communities, function(c) return(length(IsolatedNodes(c)))))

# All communities have five basal nodes
all(5==sapply(communities, function(c) return(length(BasalNodes(c)))))
```

This design makes it easy to generate artificial communities using different
structural models.


## Artifical communities that are similar to empirical ones
Create a single artificial community with randomly assigned trophic links and
with the same directed connectance as the Tuesday Lake 1984 dataset with
isolated nodes removed and nodes ordered by body mass.
```{r fig.width=12, fig.height=6}
data(TL84)
TL84 <- RemoveIsolatedNodes(OrderCommunity(TL84, 'M'), title='Tuesday Lake 1984')
random <- CommunityFactory(generator=RandomLinks,
                           C=DirectedConnectance(TL84),
                           nodes=NPS(TL84),
                           properties=CPS(TL84))
par(mfrow=c(1,2))
PlotPredationMatrix(TL84)
PlotPredationMatrix(random[[1]])
```

Points in the right-hand plot are black because`CommunityFactory` removes the
`category` column of the `nodes` data.frame because it is illegal to create a
`Community` object with nodes that have a category of producer and that have
trophic resources - something that will almost certainly happen with any 
trophic links generator.

Another one using the niche model
```{r fig.width=12, fig.height=6}
niche <- CommunityFactory(generator=NicheModelLinks,
                          C=DirectedConnectance(TL84),
                          nodes=NPS(TL84),
                          properties=CPS(TL84))
par(mfrow=c(1,2))
PlotPredationMatrix(TL84)
PlotPredationMatrix(niche[[1]])
```

We can easily create 100 niche-model communities with a C similar to TL84:
```{r}
niche <- CommunityFactory(generator=NicheModelLinks,
                          C=DirectedConnectance(TL84),
                          n=100,
                          nodes=NPS(TL84),
                          properties=CPS(TL84))
length(niche)
```

Have a look at the directed connectances of all 100 communities.
```{r}
C <- sapply(niche, DirectedConnectance)
hist(C)

# TL84's C - solid line
abline(v=DirectedConnectance(TL84), col=2)

# Mean C of generated communities - dashed line
abline(v=mean(C), lty=2)
```

Have a look at the trophic levels of all 100 communities.
```{r}
# A list of 100 vectors of length 56
tl <- lapply(niche, PreyAveragedTrophicLevel)

# The mean trophic level of each community
tl <- sapply(tl, mean)

hist(tl, xlim=range(1, range(tl)))

# Mean trophic level of TL84 - solid line
abline(v=mean(PreyAveragedTrophicLevel(TL84)), col=2)

# Mean of mean trophic level of generated communities - dashed line
abline(v=mean(tl), lty=2)
```

## Visual comparison of the different types of structural models
```{r fig.width=12, fig.height=12}
# A helper function to make the comparisons easier
Artificial <- function(original, main, ...) {
    artificial <- CommunityFactory(nodes=NPS(original),
                                   C=DirectedConnectance(original),
                                   properties=CPS(original),
                                   n=1,
                                   ...)[[1]]
    PlotPredationMatrix(artificial, main=paste0(main, ', C=',
        sprintf('%.4f', DirectedConnectance(artificial))))
    return (invisible(artificial))
}

par(mfrow=c(2,2))
PlotPredationMatrix(TL84, main=paste0('Original, C=', sprintf('%.4f', DirectedConnectance(TL84))))
Artificial(TL84, generator=RandomLinks, main='Random')
Artificial(TL84, generator=CascadeModelLinks, main='Cacade')
Artificial(TL84, generator=NicheModelLinks, main='Niche')
```

The `NicheModelLinks` function has some more flexibility. First, we can specify
species' positions on the niche axis, which takes values between 0 and 1.
Second, it can generate links using the probabilistic niche model, which allows
gaps in consumers' diets - seen in the bottom two plots.
```{r fig.width=12, fig.height=12}
par(mfrow=c(2,2))
PlotPredationMatrix(TL84, main=paste0('Original, C=', sprintf('%.4f', DirectedConnectance(TL84))))
niche.positions <- order(NP(TL84, 'M'))/NumberOfNodes(TL84)
Artificial(TL84, generator=NicheModelLinks, main='Niche,\ncentres are order of M',
           niche.positions=niche.positions)

Artificial(TL84, generator=NicheModelLinks, main='Probabilistic niche,\ncentres are order of M',
           niche.positions=niche.positions, probabilistic=TRUE)

# The allometric niche model is the probabilistic niche model with niche
# positions computed from log-transformed body masses scaled to be between 0
# and 1 (Williams et al 2010 PLoS ONE)
logM <- Log10M(TL84)
niche.positions <- (logM-min(logM)) / diff(range(logM))
Artificial(TL84, generator=NicheModelLinks, main='Probabilistic niche,\ncentres are normalised log M',
          niche.positions=niche.positions, probabilistic=TRUE)
```
